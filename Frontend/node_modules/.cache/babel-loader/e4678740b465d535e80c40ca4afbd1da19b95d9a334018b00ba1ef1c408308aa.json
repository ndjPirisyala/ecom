{"ast":null,"code":"import { productsService, recommendationService } from './api';\nimport axios from 'axios';\n\n// Maximum number of retries for transient network failures\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY = 1000; // milliseconds\n\n/**\n * Service for handling product-related operations\n * Integrates with the Products microservice\n */\nclass ProductService {\n  /**\n   * Fetch all products from the backend\n   * @returns {Promise} Promise object with products data\n   */\n  /**\n   * Helper method to handle API errors consistently\n   * @param {Error} error - The caught error\n   * @param {string} operation - Description of the operation that failed\n   * @returns {Error} Formatted error with user-friendly message\n   */\n  static _handleError(error, operation) {\n    console.error(`Error ${operation}:`, error);\n\n    // Provide detailed error information based on error type\n    const errorMessage = error.response ? `Server error: ${error.response.status} ${error.response.statusText}` : error.request ? `Network error: Unable to reach the service. Please check your connection or try again later.` : `Error: ${error.message}`;\n    return new Error(errorMessage);\n  }\n\n  /**\n   * Helper method to retry failed requests\n   * @param {Function} apiCall - The API call function to retry\n   * @param {number} retries - Number of retries remaining\n   * @returns {Promise} Promise with the API response\n   */\n  static async _retryApiCall(apiCall, retries = MAX_RETRIES) {\n    try {\n      return await apiCall();\n    } catch (error) {\n      // Only retry for network errors, not server errors\n      if (retries > 0 && (!error.response || axios.isCancel(error))) {\n        console.log(`Retrying API call, ${retries} attempts remaining`);\n        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n        return this._retryApiCall(apiCall, retries - 1);\n      }\n      throw error;\n    }\n  }\n  static async getAllProducts() {\n    try {\n      const response = await this._retryApiCall(() => productsService.getAllProducts());\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, 'fetching products');\n    }\n  }\n\n  /**\n   * Fetch a single product by ID\n   * @param {string} productId - The ID of the product to fetch\n   * @returns {Promise} Promise object with product data\n   */\n  static async getProduct(productId) {\n    try {\n      const response = await this._retryApiCall(() => productsService.getProduct(productId));\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, `fetching product ${productId}`);\n    }\n  }\n\n  /**\n   * Fetch products by category\n   * @param {string} category - The category to filter by\n   * @returns {Promise} Promise object with filtered products data\n   */\n  static async getProductsByCategory(category) {\n    try {\n      const response = await this._retryApiCall(() => productsService.getProductsByCategory(category));\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, `fetching products in category ${category}`);\n    }\n  }\n\n  /**\n   * Search for products using the semantic search endpoint\n   * @param {string} query - The search query\n   * @returns {Promise} Promise object with search results\n   */\n  static async searchProducts(query) {\n    try {\n      const response = await this._retryApiCall(() => productsService.searchProducts(query));\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, `searching products with query \"${query}\"`);\n    }\n  }\n\n  /**\n   * Get product recommendations based on a product ID\n   * @param {string} productId - The ID of the product to get recommendations for\n   * @returns {Promise} Promise object with recommended products\n   */\n  static async getRecommendations(productId) {\n    try {\n      // Using the correct recommendationService instead of productsService\n      const response = await this._retryApiCall(() => recommendationService.getProductRecommendations(productId));\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, `fetching recommendations for product ${productId}`);\n    }\n  }\n\n  //////////////////////////////////////////////////////\n\n  static async getHotPicks() {\n    try {\n      const response = await this._retryApiCall(() => productsService.getHotPicks());\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, 'fetching products');\n    }\n  }\n  static async getNewArrivals() {\n    try {\n      const response = await this._retryApiCall(() => productsService.getNewArrivals());\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, 'fetching products');\n    }\n  }\n  static async getBestSellers() {\n    try {\n      const response = await this._retryApiCall(() => productsService.getBestSellers());\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, 'fetching products');\n    }\n  }\n}\nexport default ProductService;","map":{"version":3,"names":["productsService","recommendationService","axios","MAX_RETRIES","RETRY_DELAY","ProductService","_handleError","error","operation","console","errorMessage","response","status","statusText","request","message","Error","_retryApiCall","apiCall","retries","isCancel","log","Promise","resolve","setTimeout","getAllProducts","data","getProduct","productId","getProductsByCategory","category","searchProducts","query","getRecommendations","getProductRecommendations","getHotPicks","getNewArrivals","getBestSellers"],"sources":["C:/Users/nadee/OneDrive/Documents/Ecommerce-Microservices-dev/Ecommerce-Microservices-dev/Frontend/src/services/ProductService.js"],"sourcesContent":["import { productsService, recommendationService } from './api';\nimport axios from 'axios';\n\n// Maximum number of retries for transient network failures\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY = 1000; // milliseconds\n\n/**\n * Service for handling product-related operations\n * Integrates with the Products microservice\n */\nclass ProductService {\n  /**\n   * Fetch all products from the backend\n   * @returns {Promise} Promise object with products data\n   */\n  /**\n   * Helper method to handle API errors consistently\n   * @param {Error} error - The caught error\n   * @param {string} operation - Description of the operation that failed\n   * @returns {Error} Formatted error with user-friendly message\n   */\n  static _handleError(error, operation) {\n    console.error(`Error ${operation}:`, error);\n    \n    // Provide detailed error information based on error type\n    const errorMessage = error.response ? \n      `Server error: ${error.response.status} ${error.response.statusText}` : \n      error.request ? \n        `Network error: Unable to reach the service. Please check your connection or try again later.` : \n        `Error: ${error.message}`;\n    \n    return new Error(errorMessage);\n  }\n\n  /**\n   * Helper method to retry failed requests\n   * @param {Function} apiCall - The API call function to retry\n   * @param {number} retries - Number of retries remaining\n   * @returns {Promise} Promise with the API response\n   */\n  static async _retryApiCall(apiCall, retries = MAX_RETRIES) {\n    try {\n      return await apiCall();\n    } catch (error) {\n      // Only retry for network errors, not server errors\n      if (retries > 0 && (!error.response || axios.isCancel(error))) {\n        console.log(`Retrying API call, ${retries} attempts remaining`);\n        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n        return this._retryApiCall(apiCall, retries - 1);\n      }\n      throw error;\n    }\n  }\n\n  static async getAllProducts() {\n    try {\n      const response = await this._retryApiCall(() => productsService.getAllProducts());\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, 'fetching products');\n    }\n  }\n\n  /**\n   * Fetch a single product by ID\n   * @param {string} productId - The ID of the product to fetch\n   * @returns {Promise} Promise object with product data\n   */\n  static async getProduct(productId) {\n    try {\n      const response = await this._retryApiCall(() => productsService.getProduct(productId));\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, `fetching product ${productId}`);\n    }\n  }\n\n  /**\n   * Fetch products by category\n   * @param {string} category - The category to filter by\n   * @returns {Promise} Promise object with filtered products data\n   */\n  static async getProductsByCategory(category) {\n    try {\n      const response = await this._retryApiCall(() => productsService.getProductsByCategory(category));\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, `fetching products in category ${category}`);\n    }\n  }\n\n  /**\n   * Search for products using the semantic search endpoint\n   * @param {string} query - The search query\n   * @returns {Promise} Promise object with search results\n   */\n  static async searchProducts(query) {\n    try {\n      const response = await this._retryApiCall(() => productsService.searchProducts(query));\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, `searching products with query \"${query}\"`);\n    }\n  }\n\n  /**\n   * Get product recommendations based on a product ID\n   * @param {string} productId - The ID of the product to get recommendations for\n   * @returns {Promise} Promise object with recommended products\n   */\n  static async getRecommendations(productId) {\n    try {\n      // Using the correct recommendationService instead of productsService\n      const response = await this._retryApiCall(() => recommendationService.getProductRecommendations(productId));\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, `fetching recommendations for product ${productId}`);\n    }\n  }\n\n  //////////////////////////////////////////////////////\n\n  static async getHotPicks() {\n    try {\n      const response = await this._retryApiCall(() => productsService.getHotPicks());\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, 'fetching products');\n    }\n  }\n\n  static async getNewArrivals() {\n    try {\n      const response = await this._retryApiCall(() => productsService.getNewArrivals());\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, 'fetching products');\n    }\n  }\n\n  static async getBestSellers() {\n    try {\n      const response = await this._retryApiCall(() => productsService.getBestSellers());\n      return response.data;\n    } catch (error) {\n      throw this._handleError(error, 'fetching products');\n    }\n  }\n}\n\nexport default ProductService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}